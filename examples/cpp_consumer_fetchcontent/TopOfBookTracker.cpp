#include "TopOfBookTracker.h"
#include <chrono>
#include <sstream>
#include <iomanip>
#include <ctime>
#include <iostream>
#include <algorithm>

TopOfBookTracker::TopOfBookTracker(const std::string& symbol, const std::string& date_range) 
    : symbol_(symbol), date_range_(date_range), csv_enabled_(false) {
    
    // Generate default filename if symbol and date_range are provided
    if (!symbol.empty() && !date_range.empty()) {
        // Create filename: TOB_<symbol>_<date_range>.csv
        std::string filename = "TOB_" + symbol + "_" + date_range + ".csv";
        
        // Replace problematic characters for filename (but preserve the TOB prefix)
        std::replace(filename.begin(), filename.end(), ':', '-');
        // Replace 'T' with '_' only in date/time parts, not in the "TOB" prefix
        size_t tob_prefix_len = 4; // "TOB_" length
        if (filename.length() > tob_prefix_len) {
            std::replace(filename.begin() + tob_prefix_len, filename.end(), 'T', '_');
        }
        std::replace(filename.begin(), filename.end(), '/', '-');
        
        EnableCSV(filename);
    }
    
    std::cout << "[TOB] Initialized Top of Book tracker";
    if (!symbol.empty()) {
        std::cout << " for symbol " << symbol;
    }
    if (!date_range.empty()) {
        std::cout << " (" << date_range << ")";
    }
    std::cout << std::endl;
}

TopOfBookTracker::~TopOfBookTracker() {
    if (csv_file_.is_open()) {
        csv_file_.flush(); // Ensure all data is written
        csv_file_.close();
    }
}

void TopOfBookTracker::EnableCSV(const std::string& filename) {
    if (csv_file_.is_open()) {
        csv_file_.close();
    }
    
    csv_filename_ = filename;
    csv_enabled_ = !filename.empty();
    
    if (csv_enabled_) {
        csv_file_.open(csv_filename_, std::ios::out | std::ios::trunc);
        if (csv_file_.is_open()) {
            // Write CSV documentation header
            csv_file_ << "# Top of Book CSV Output\n";
            csv_file_ << "# Generated by TopOfBookTracker\n";
            csv_file_ << "# Symbol: " << symbol_ << "\n";
            csv_file_ << "# Date Range: " << date_range_ << "\n";
            csv_file_ << "# Columns:\n";
            csv_file_ << "#   timestamp: ISO 8601 timestamp (YYYY-MM-DDTHH:MM:SS.nnnnnnnnnZ)\n";
            csv_file_ << "#   symbol: Trading symbol\n";
            csv_file_ << "#   best_bid: Best bid price in dollars (converted from ticks)\n";
            csv_file_ << "#   best_ask: Best ask price in dollars (converted from ticks)\n";
            csv_file_ << "#   bid_volume: Volume at best bid level\n";
            csv_file_ << "#   ask_volume: Volume at best ask level\n";
            csv_file_ << "#   mid_price: Mid price in dollars ((bid + ask) / 2)\n";
            csv_file_ << "#   spread: Bid-ask spread in dollars (ask - bid)\n";
            csv_file_ << "\n";
            
            WriteCSVHeader();
            std::cout << "[TOB] CSV logging enabled: " << csv_filename_ << std::endl;
        } else {
            csv_enabled_ = false;
            std::cout << "[TOB] Failed to open CSV file: " << csv_filename_ << std::endl;
        }
    }
}

void TopOfBookTracker::DisableCSV() {
    if (csv_file_.is_open()) {
        csv_file_.close();
    }
    csv_enabled_ = false;
    std::cout << "[TOB] CSV logging disabled" << std::endl;
}

void TopOfBookTracker::WriteCSVHeader() {
    if (!csv_enabled_ || !csv_file_.is_open()) return;
    
    csv_file_ << "timestamp,symbol,best_bid,best_ask,bid_volume,ask_volume,mid_price,spread\n";
    csv_file_.flush();
}

std::string TopOfBookTracker::TimestampToString(uint64_t timestamp_ns) const {
    // Convert nanoseconds to seconds for standard time conversion
    auto timestamp_seconds = std::chrono::seconds(timestamp_ns / 1000000000);
    auto timestamp_nanos_remainder = timestamp_ns % 1000000000;
    
    // Convert to time_point
    auto time_point = std::chrono::system_clock::time_point(timestamp_seconds);
    
    // Convert to time_t for formatting
    std::time_t time_t_val = std::chrono::system_clock::to_time_t(time_point);
    
    // Format as ISO 8601 string with nanosecond precision
    std::ostringstream oss;
    oss << std::put_time(std::gmtime(&time_t_val), "%Y-%m-%dT%H:%M:%S");
    oss << "." << std::setfill('0') << std::setw(9) << timestamp_nanos_remainder << "Z";
    
    return oss.str();
}

void TopOfBookTracker::WriteSnapshotToCSV(const TOBSnapshot& snapshot) {
    if (!csv_enabled_ || !csv_file_.is_open()) return;
    
    // Convert timestamp to readable string
    std::string timestamp_str = TimestampToString(snapshot.timestamp);
    
    csv_file_ << timestamp_str << ","
              << snapshot.symbol << ","
              << std::fixed << std::setprecision(2) << snapshot.best_bid << ","
              << std::fixed << std::setprecision(2) << snapshot.best_ask << ","
              << snapshot.bid_volume << ","
              << snapshot.ask_volume << ","
              << std::fixed << std::setprecision(2) << snapshot.mid_price << ","
              << std::fixed << std::setprecision(2) << snapshot.spread << "\n";
    
    // Flush periodically for better performance (every 10th write)
    static int write_count = 0;
    if (++write_count % 10 == 0) {
        csv_file_.flush();
    }
}

void TopOfBookTracker::OnTopOfBookUpdate(uint64_t timestamp, const std::string& symbol, 
                                        uint64_t best_bid, uint64_t best_ask, 
                                        uint64_t bid_volume, uint64_t ask_volume) {
    if (timestamp == 0) {
        timestamp = std::chrono::duration_cast<std::chrono::nanoseconds>(
            std::chrono::system_clock::now().time_since_epoch()).count();
    }
    
    // Convert prices from ticks to dollars (divide by 100)
    double bid_dollars = best_bid / 100.0;
    double ask_dollars = best_ask / 100.0;
    
    TOBSnapshot snapshot(timestamp, symbol, bid_dollars, ask_dollars, bid_volume, ask_volume);
    
    if (csv_enabled_) {
        WriteSnapshotToCSV(snapshot);
    }
}

void TopOfBookTracker::UpdateSymbol(const std::string& symbol) {
    if (symbol != symbol_ && !symbol.empty()) {
        symbol_ = symbol;
        
        // If CSV is enabled, update the filename and restart logging
        if (csv_enabled_) {
            std::string old_filename = csv_filename_;
            DisableCSV();
            
            // Generate new filename with updated symbol
            std::string new_filename = "TOB_" + symbol_ + "_" + date_range_ + ".csv";
            std::replace(new_filename.begin(), new_filename.end(), ':', '-');
            // Replace 'T' with '_' only in date/time parts, not in the "TOB" prefix
            size_t tob_prefix_len = 4; // "TOB_" length
            if (new_filename.length() > tob_prefix_len) {
                std::replace(new_filename.begin() + tob_prefix_len, new_filename.end(), 'T', '_');
            }
            std::replace(new_filename.begin(), new_filename.end(), '/', '-');
            
            EnableCSV(new_filename);
            std::cout << "[TOB] Updated symbol to " << symbol_ << ", CSV file: " << new_filename << std::endl;
        }
    }
}
